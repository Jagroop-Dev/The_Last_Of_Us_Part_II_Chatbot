import streamlit as st
import os
import re
from langchain_huggingface import HuggingFaceEmbeddings
from langchain.chains import RetrievalQA
from langchain_core.prompts import PromptTemplate
from langchain_huggingface import HuggingFaceEndpoint, ChatHuggingFace
from langchain_community.vectorstores import FAISS
from langchain_core.documents import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from sentence_transformers import SentenceTransformer
from langchain_community.document_loaders import PyPDFLoader, DirectoryLoader


FAISS_DB_PATH = 'FAISS Database/'

# Image folder mappings - supporting both relative path formats
IMAGE_FOLDERS = {
    'chapter_images': ['../Data/Images/chapter_images', 'Data/Images/chapter_images'],
    'chapter_section_images': ['../Data/Images/chapter_section_images', 'Data/Images/chapter_section_images'],
    'character_images': ['../Data/Images/character_images', 'Data/Images/character_images'],
    'enemy_images': ['../Data/Images/enemy_images', 'Data/Images/enemy_images'],
    'safe_images': ['../Data/Images/safe_images', 'Data/Images/safe_images'],
    'trophy_images': ['../Data/Images/trophy_images', 'Data/Images/trophy_images'],
    'weapon_images': ['../Data/Images/weapon_images', 'Data/Images/weapon_images']
}

@st.cache_resource
def get_vectorstore():
    embedding_model = HuggingFaceEmbeddings(model_name="sentence-transformers/all-MiniLM-L12-v2")
    db = FAISS.load_local(FAISS_DB_PATH, embedding_model, allow_dangerous_deserialization=True)
    return db

def extract_image_paths(text):
    """Extract image paths from text using regex patterns"""
    patterns = [
        r'Image:\s*([^)]+\.(jpeg|jpg|png|gif|bmp|webp))',
        r'\(Image:\s*([^)]+\.(jpeg|jpg|png|gif|bmp|webp))\)',
        r'Image:\s*([^\n]+\.(jpeg|jpg|png|gif|bmp|webp))',
        r'Image:\s*([^,\n\r]+\.(jpeg|jpg|png|gif|bmp|webp))',
    ]
    all_extracted_paths = []
    for pattern in patterns:
        matches = re.findall(pattern, text, re.IGNORECASE)
        if matches and isinstance(matches[0], tuple):
            paths = [match[0].strip() for match in matches]
        else:
            paths = [match.strip() for match in matches] if matches else []
        for path in paths:
            if path not in all_extracted_paths:
                all_extracted_paths.append(path)
    return all_extracted_paths

def clean_response_text(text):
    """Remove image references from the response text"""
    cleaned_text = re.sub(r'\s*\(Image:\s*[^)]+\)', '', text, flags=re.IGNORECASE)
    cleaned_text = re.sub(r'\s*Image:\s*[^\n]+', '', cleaned_text, flags=re.IGNORECASE)
    cleaned_text = re.sub(r'\n\s*\n', '\n\n', cleaned_text)
    cleaned_text = re.sub(r'\s+', ' ', cleaned_text)
    return cleaned_text.strip()

def get_image_category(img_path):
    """Determine which category an image belongs to based on its path"""
    img_path_lower = img_path.lower()
    if 'character' in img_path_lower:
        return 'character_images'
    elif 'weapon' in img_path_lower:
        return 'weapon_images'
    elif 'enemy' in img_path_lower:
        return 'enemy_images'
    elif 'chapter_section' in img_path_lower:
        return 'chapter_section_images'
    elif 'chapter' in img_path_lower:
        return 'chapter_images'
    elif 'safe' in img_path_lower:
        return 'safe_images'
    elif 'trophy' in img_path_lower:
        return 'trophy_images'
    else:
        return None

def find_image_with_flexible_extension(folder_path, base_filename):
    """Find an image file with flexible extension matching"""
    if not os.path.exists(folder_path):
        return None, None
    name_without_ext = os.path.splitext(base_filename)[0]
    extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']
    for ext in extensions:
        potential_file = name_without_ext + ext
        potential_path = os.path.join(folder_path, potential_file)
        if os.path.exists(potential_path):
            return potential_path, potential_file
    return None, None

def display_images(image_paths):
    """Display images in Streamlit if they exist"""
    displayed_images = []
    for img_path in image_paths:
        img_path = img_path.strip()
        found = False
        if os.path.exists(img_path):
            try:
                st.image(img_path, width=300, caption=os.path.basename(img_path))
                displayed_images.append(img_path)
                found = True
                continue
            except Exception:
                pass
        filename = os.path.basename(img_path)
        likely_category = get_image_category(img_path)
        search_order = []
        if likely_category and likely_category in IMAGE_FOLDERS:
            search_order.append((likely_category, IMAGE_FOLDERS[likely_category]))
            for cat, paths in IMAGE_FOLDERS.items():
                if cat != likely_category:
                    search_order.append((cat, paths))
        else:
            search_order = list(IMAGE_FOLDERS.items())
        for folder_name, folder_paths in search_order:
            if found:
                break
            for folder_path in folder_paths:
                if not os.path.exists(folder_path):
                    continue
                potential_path = os.path.join(folder_path, filename)
                if os.path.exists(potential_path):
                    try:
                        st.image(potential_path, width=300, caption=os.path.basename(filename))
                        displayed_images.append(potential_path)
                        found = True
                        break
                    except Exception:
                        continue
                else:
                    flexible_path, flexible_filename = find_image_with_flexible_extension(folder_path, filename)
                    if flexible_path:
                        try:
                            st.image(flexible_path, width=300, caption=os.path.basename(flexible_filename))
                            displayed_images.append(flexible_path)
                            found = True
                            break
                        except Exception:
                            continue
    return displayed_images

def format_response_with_images(response_text, source_documents=None):
    """Format response, clean text, and display images"""
    image_paths_in_response = extract_image_paths(response_text)
    cleaned_text = clean_response_text(response_text)
    with st.chat_message('assistant'):
        st.markdown(cleaned_text)
        if image_paths_in_response:
            displayed = display_images(image_paths_in_response)
    return cleaned_text, image_paths_in_response

def set_custom_prompt(custom_prompt_template):
    prompt = PromptTemplate(template=custom_prompt_template, input_variables=["context", "question"])
    return prompt

def load_llm(huggingface_repo_id, HF_TOKEN):
    llm = HuggingFaceEndpoint(
        repo_id=huggingface_repo_id,
        temperature=0.5,
        huggingfacehub_api_token=HF_TOKEN,
        task='conversational'
    )
    return llm

def main():
    st.title("WLF")
    

    with st.sidebar:
        st.header("Settings")
        
        # Font Size/Accessibility
        font_size = st.slider("Adjust Font Size", min_value=12, max_value=24, value=16)
        st.markdown(f"""
        <style>
            html, body, [class*="st-"] {{
                font-size: {font_size}px;
            }}
        </style>
        """, unsafe_allow_html=True)
    

    prompt = None
    
    text_prompt = st.chat_input("Ask WLF...")
    if text_prompt:
        prompt = text_prompt

    if prompt:
        st.chat_message('user').markdown(prompt)
        
        custom_prompt_template = """
You are a The Last of Us Part 2 expert assistant. Use the provided context to answer the user's question accurately and comprehensively.

IMPORTANT GUIDELINES:
- Answer directly and concisely - no small talk or greetings
- If the context contains spoiler warnings (⚠️), include them in your response before revealing spoilers
- If the context talks about someone dying, include a spoiler warning (⚠️) before revealing the death, e.g., "⚠️ Spoiler Alert: [character] dies..."
- When relevant, include image paths exactly as shown in the context (e.g., "Image: ../Data/Images/...")
- For counting questions (how many weapons, characters, etc.), provide specific numbers and breakdowns
- If you don't know the answer from the given context, state "I don't have that information in the provided context"
- Stick strictly to the provided context - do not add external knowledge
- For weapon/item locations, include the specific chapter and area mentioned
- For safe codes, provide both the code and the method to find it

Context: {context}
Question: {question}
Answer:"""
        
        huggingface_repo_id = "mistralai/Mistral-7B-Instruct-v0.3"
        HF_TOKEN = st.secrets["HF_TOKEN"]
        
        try:
            vectorstore = get_vectorstore()
            if vectorstore is None:
                st.error("Failed to load the vector store")
                return
                
            chat_model = ChatHuggingFace(llm=load_llm(huggingface_repo_id=huggingface_repo_id, HF_TOKEN=HF_TOKEN))
            
            qa_chain = RetrievalQA.from_chain_type(
                llm=chat_model,
                chain_type="stuff",
                retriever=vectorstore.as_retriever(search_kwargs={'k':3}),
                return_source_documents=True,
                chain_type_kwargs={'prompt':set_custom_prompt(custom_prompt_template)}
            )
            
            response = qa_chain.invoke({'query': prompt})
            result = response["result"]
            
            format_response_with_images(result, response["source_documents"])
            
        except Exception as e:
            st.error(f"Error: {str(e)}")

if __name__ == "__main__":
    main()